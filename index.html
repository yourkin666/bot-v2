<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title> AI 小子</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css" rel="stylesheet">
<script src="https://cdn.tailwindcss.com/3.4.16"></script>
<script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
<script>
tailwind.config = {
theme: {
extend: {
colors: {
primary: '#3B82F6',
secondary: '#6B7280'
},
borderRadius: {
'none': '0px',
'sm': '4px',
DEFAULT: '8px',
'md': '12px',
'lg': '16px',
'xl': '20px',
'2xl': '24px',
'3xl': '32px',
'full': '9999px',
'button': '8px'
}
}
}
}
</script>
<style>
/* 移除强制图标内容，让图标正常显示 */

/* 页面基础样式 - 移除默认边距和设置全高度 */
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

html, body {
height: 100%;
min-height: 100vh;
overflow: hidden;
}

.chat-container {
height: calc(100vh - 80px);
}
.message-input:focus {
outline: none;
}
.history-item {
transition: all 0.2s ease;
}
.history-item:hover {
background-color: rgb(239 246 255);
color: rgb(37 99 235);
}
.active-chat {
background: rgb(239 246 255);
color: rgb(37 99 235);
}
.active-chat:hover {
background: rgb(219 234 254);
color: rgb(29 78 216);
transform: none;
}
.thinking-process {
max-height: 0;
overflow: hidden;
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.thinking-process.expanded {
max-height: 500px;
}
.chat-messages::-webkit-scrollbar {
width: 6px;
}
.chat-messages::-webkit-scrollbar-track {
background: transparent;
}
.chat-messages::-webkit-scrollbar-thumb {
background-color: #E5E7EB;
border-radius: 20px;
}
.glass-effect {
background: rgba(255, 255, 255, 0.8);
backdrop-filter: blur(16px);
box-shadow:
0 8px 32px rgba(0, 0, 0, 0.03),
0 1px 2px rgba(255, 255, 255, 0.2) inset,
0 -1px 2px rgba(0, 0, 0, 0.03) inset;
border: 1px solid rgba(255, 255, 255, 0.4);
}
.message-input {
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.message-input:focus {
background-color: white;
box-shadow:
0 4px 12px rgba(59, 130, 246, 0.08),
0 2px 4px rgba(59, 130, 246, 0.03);
border: 1px solid rgba(59, 130, 246, 0.1);
}
.button-hover-effect {
transition: all 0.2s ease;
}
.button-hover-effect:hover {
transform: translateY(-2px);
box-shadow:
0 4px 16px rgba(59, 130, 246, 0.25),
0 2px 4px rgba(59, 130, 246, 0.1);
}
.button-hover-effect:active {
transform: translateY(0);
}
.toggle-button.active {
background-color: rgb(59, 130, 246);
color: white;
}
.toggle-button.active:hover {
background-color: rgb(37, 99, 235);
}
.typing-cursor {
animation: blink 1s infinite;
font-weight: bold;
color: #3B82F6;
}
@keyframes blink {
0%, 50% { opacity: 1; }
51%, 100% { opacity: 0; }
}

/* 输入框响应状态动画 */
@keyframes pulse-border {
0%, 100% { 
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  border-color: #3B82F6;
}
50% { 
  box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
  border-color: #1D4ED8;
}
}

/* 中断提示动画 */
@keyframes bounce-in {
0% {
  opacity: 0;
  transform: translateY(10px) scale(0.8);
}
50% {
  transform: translateY(-5px) scale(1.05);
}
100% {
  opacity: 1;
  transform: translateY(0) scale(1);
}
}

@keyframes fade-out {
0% {
  opacity: 1;
  transform: scale(1);
}
100% {
  opacity: 0;
  transform: scale(0.9);
}
}

/* 中断按钮脉冲效果 */
@keyframes interrupt-pulse {
0%, 100% {
  box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
  transform: scale(1.05);
}
50% {
  box-shadow: 0 0 0 6px rgba(239, 68, 68, 0.2);
  transform: scale(1.08);
}
}

/* 删除按钮样式 */
.delete-chat-btn {
transition: all 0.2s ease;
}
.delete-chat-btn:hover {
transform: scale(1.1);
}
.delete-chat-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}

/* 新对话按钮禁用状态 */
.new-chat-btn:disabled {
opacity: 0.6;
cursor: not-allowed;
transform: none !important;
}

/* 历史记录项hover效果 */
.history-item .group:hover {
background-color: rgba(239, 246, 255, 0.5);
}

/* 模态框动画 */
.modal-enter {
animation: modalEnter 0.3s ease-out;
}
@keyframes modalEnter {
from {
opacity: 0;
transform: scale(0.9);
}
to {
opacity: 1;
transform: scale(1);
}
}

/* 提示框样式 */
.toast {
backdrop-filter: blur(8px);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

/* 历史记录项选中状态 */
.history-item.active-chat {
background: linear-gradient(135deg, #EEF3FE 0%, #E0EFFF 100%);
border-left: 3px solid #4E89FD;
}

/* Markdown 样式 */
.markdown-content h1 {
font-size: 1.875rem;
font-weight: 700;
margin: 1.5rem 0 1rem 0;
line-height: 1.2;
color: #1f2937;
}
.markdown-content h2 {
font-size: 1.5rem;
font-weight: 600;
margin: 1.25rem 0 0.75rem 0;
line-height: 1.3;
color: #374151;
}
.markdown-content h3 {
font-size: 1.25rem;
font-weight: 600;
margin: 1rem 0 0.5rem 0;
line-height: 1.4;
color: #4b5563;
}
.markdown-content p {
margin: 0.75rem 0;
line-height: 1.6;
color: #374151;
}
.markdown-content strong {
font-weight: 600;
color: #1f2937;
}
.markdown-content em {
font-style: italic;
color: #4b5563;
}
.markdown-content code {
background-color: #f3f4f6;
padding: 0.125rem 0.25rem;
border-radius: 0.25rem;
font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
font-size: 0.875rem;
color: #dc2626;
}
.markdown-content pre {
background-color: #1f2937;
color: #f9fafb;
padding: 1rem;
border-radius: 0.5rem;
overflow-x: auto;
margin: 1rem 0;
}
.markdown-content pre code {
background-color: transparent;
padding: 0;
color: inherit;
font-size: 0.875rem;
}
.markdown-content ul, .markdown-content ol {
margin: 0.75rem 0;
padding-left: 1.5rem;
}
.markdown-content li {
margin: 0.25rem 0;
line-height: 1.5;
}
.markdown-content blockquote {
border-left: 4px solid #3b82f6;
background-color: #eff6ff;
padding: 0.75rem 1rem;
margin: 1rem 0;
font-style: italic;
color: #1e40af;
}
.markdown-content a {
color: #3b82f6;
text-decoration: underline;
}
.markdown-content a:hover {
color: #1d4ed8;
}
.markdown-content table {
width: 100%;
border-collapse: collapse;
margin: 1rem 0;
}
.markdown-content th, .markdown-content td {
border: 1px solid #d1d5db;
padding: 0.5rem;
text-align: left;
}
.markdown-content th {
background-color: #f9fafb;
font-weight: 600;
}
.markdown-content hr {
border: none;
border-top: 1px solid #e5e7eb;
margin: 1.5rem 0;
}

/* 数学公式样式 */
.katex {
font-size: 1em;
}
.katex-display {
margin: 1rem 0;
text-align: center;
}
.markdown-content .katex-display {
background-color: #f8fafc;
padding: 1rem;
border-radius: 0.5rem;
border: 1px solid #e2e8f0;
overflow-x: auto;
}
.markdown-content .katex-html {
overflow-x: auto;
overflow-y: hidden;
}
</style>
</head>
<body class="bg-[conic-gradient(at_top,_var(--tw-gradient-stops))] from-white via-sky-50 to-blue-50/30 font-sans text-gray-900">
<div class="flex h-full w-full">
<!-- 左侧边栏 -->
<div class="w-64 bg-white/90 backdrop-blur-2xl border-r border-white/50 flex flex-col shadow-[0_0_50px_rgba(0,0,0,0.05)]">
<!-- 品牌标识 -->
<div class="p-4 flex items-center justify-between">
		<div class="flex items-center gap-3">
			<!-- Logo图标 -->
			<div class="relative">
				<div class="w-10 h-10 bg-gradient-to-br from-blue-500 via-purple-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-lg shadow-blue-200/50 transform rotate-3 hover:rotate-0 transition-transform duration-300">
					<i class="ri-robot-line text-white text-lg"></i>
				</div>
				<div class="absolute -top-1 -right-1 w-3 h-3 bg-gradient-to-r from-green-400 to-blue-500 rounded-full animate-pulse"></div>
			</div>
			<!-- Logo文字 -->
			<div class="flex flex-col">
				<div class="font-bold text-xl bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-600 bg-clip-text text-transparent">
					AI小子
				</div>
				<div class="text-xs text-gray-400 font-medium tracking-wide">
					智能助手
				</div>
			</div>
		</div>
<div class="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700 transition-colors cursor-pointer">
<i class="ri-menu-line ri-lg"></i>
</div>
</div>
<!-- 新对话按钮 -->
<div class="p-3">
		<button id="sidebar-new-chat-btn" class="new-chat-btn bg-blue-50 text-blue-600 py-1.5 px-4 flex items-center justify-center gap-1.5 rounded-full hover:bg-blue-100 transition-colors text-sm mx-auto whitespace-nowrap">
			<i class="ri-add-line text-xs"></i>
			<span>开启新对话</span>
		</button>
</div>
<!-- 对话历史 -->
<div class="flex-1 overflow-y-auto">
	<div id="history-container">
		<!-- 历史对话将在这里动态加载 -->
		<div class="p-3 text-center text-gray-400 text-sm">
			<i class="ri-loader-4-line animate-spin mr-1"></i>
			正在加载历史对话...
</div>
</div>
</div>
<!-- 底部功能区 -->
<div class="p-3 border-t border-gray-100 space-y-2">
<!-- 功能区域预留，可以添加其他工具 -->
</div>
</div>
<!-- 中间聊天区域 -->
<div class="flex-1 flex flex-col bg-white">
<!-- 聊天消息区域 -->
<div class="flex-1 overflow-y-auto chat-messages p-4">
<!-- 初始欢迎信息 -->
<div id="welcome-message" class="flex flex-col items-center justify-center h-full">
<div class="relative mb-6">
<div class="w-20 h-20 bg-gradient-to-br from-blue-500 via-purple-500 to-indigo-600 rounded-2xl flex items-center justify-center shadow-2xl shadow-blue-200/50 ring-8 ring-white/80 backdrop-blur-xl transform rotate-3 hover:rotate-0 transition-transform duration-500">
<i class="ri-robot-line text-white text-3xl"></i>
</div>
<div class="absolute -top-2 -right-2 w-6 h-6 bg-gradient-to-r from-green-400 to-blue-500 rounded-full animate-pulse flex items-center justify-center">
<div class="w-2 h-2 bg-white rounded-full"></div>
</div>
</div>
			<h2 class="text-xl font-medium mb-2">我是 <span class="bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-600 bg-clip-text text-transparent font-bold">AI小子</span>，很高兴见到你！</h2>
<p class="text-gray-500 text-center max-w-md mb-4">我可以帮你写代码、回答问题、生成内容，甚至可以进行深度思考。请把你的任务交给我吧～</p>
</div>
<!-- 聊天消息容器 (动态生成内容) -->
<div id="chat-content" class="hidden space-y-6">
<!-- 真实的聊天消息将在这里动态显示 -->
</div>
</div>
<!-- 新对话按钮 (初始隐藏) -->
<div id="new-chat-button" class="hidden px-4 py-2">
	<button id="chat-new-chat-btn" class="new-chat-btn bg-[#EEF3FE] text-[#4E89FD] py-1.5 px-4 flex items-center justify-center gap-1.5 rounded-full hover:bg-blue-100 transition-colors text-sm mx-auto whitespace-nowrap">
		<i class="ri-add-line text-xs"></i>
		<span>开启新对话</span>
	</button>
</div>
<!-- 输入区域 -->
<div class="p-4">
<div class="flex items-center gap-2 mb-3">
		<button id="thinking-toggle" class="toggle-button bg-blue-50 text-blue-600 py-1.5 px-3 rounded-lg text-sm flex items-center gap-1 whitespace-nowrap hover:bg-blue-100 transition-colors">
			<div class="w-4 h-4 flex items-center justify-center">
				<i class="ri-brain-line"></i>
			</div>
			<span>深度思考 (R1)</span>
		</button>
		<button id="search-toggle" class="toggle-button bg-gray-50 text-gray-600 py-1.5 px-3 rounded-lg text-sm flex items-center gap-1 whitespace-nowrap hover:bg-gray-100 transition-colors">
			<div class="w-4 h-4 flex items-center justify-center">
				<i class="ri-search-line"></i>
			</div>
			<span>联网搜索</span>
		</button>
</div>
<div class="relative">
<textarea
class="message-input w-full bg-gray-50 rounded-lg pl-4 pr-12 py-3 resize-none border-none h-12 text-gray-800 focus:bg-gray-100 transition-colors"
				placeholder="给 AI小子 发送消息"
rows="1"
></textarea>
<div class="absolute right-3 top-1/2 -translate-y-1/2 flex items-center gap-2">
<button class="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700">
<i class="ri-attachment-2"></i>
</button>
<button id="send-button" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-primary">
<i class="ri-send-plane-fill"></i>
</button>
</div>
</div>
</div>
</div>
</div>
<script id="chat-interaction">
// 简化的Markdown渲染函数 - 直接处理，让KaTeX后续渲染数学公式
function renderMarkdown(text) {
if (typeof marked === 'undefined') {
return text.replace(/\n/g, '<br>');
}

try {
console.log('渲染Markdown文本:', text.substring(0, 100) + '...');

// 配置marked选项
marked.setOptions({
breaks: true,
gfm: true,
sanitize: false
});

// 直接渲染Markdown，不进行复杂的占位符处理
// 让KaTeX在后续步骤中直接处理数学公式
let rendered = marked.parse(text);

// 使用DOMPurify清理HTML以防止XSS攻击
rendered = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(rendered, {
ADD_TAGS: ['math', 'semantics', 'mrow', 'mi', 'mo', 'mn', 'msup', 'msub', 'mfrac', 'msqrt'],
ADD_ATTR: ['class', 'style']
}) : rendered;

// 清理任何可能的占位符残留
rendered = cleanupMathPlaceholders(rendered);

console.log('最终渲染结果预览:', rendered.substring(0, 200) + '...');
return rendered;
} catch (error) {
console.error('Markdown渲染错误:', error);
return text.replace(/\n/g, '<br>');
}
}

// 清理数学公式占位符的辅助函数
function cleanupMathPlaceholders(text) {
// 移除所有形如 MATH_BLOCK_N 或 MATH_INLINE_N 的占位符
text = text.replace(/MATH_(BLOCK|INLINE)_\d+/g, '[数学公式]');
// 移除所有形如 __MATH_BLOCK_N__ 或 __MATH_INLINE_N__ 的占位符
text = text.replace(/__MATH_(BLOCK|INLINE)_\d+__/g, '[数学公式]');
return text;
}

// 这些函数已经不再需要，因为我们简化了渲染逻辑

// 转义正则表达式特殊字符
function escapeRegExp(string) {
return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// 数学公式渲染配置
const mathConfig = {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError: false,
errorColor: '#cc0000',
strict: false
};

// 等待KaTeX加载完成的函数
function waitForKaTeX() {
return new Promise((resolve, reject) => {
if (typeof window.renderMathInElement === 'function') {
resolve();
return;
}

let attempts = 0;
const maxAttempts = 50; // 5秒超时
const checkKaTeX = setInterval(() => {
attempts++;
console.log(`检查KaTeX加载状态，尝试 ${attempts}/${maxAttempts}`, typeof window.renderMathInElement);

if (typeof window.renderMathInElement === 'function') {
clearInterval(checkKaTeX);
console.log('✅ KaTeX加载完成');
resolve();
} else if (attempts >= maxAttempts) {
clearInterval(checkKaTeX);
console.error('❌ KaTeX加载超时');
reject(new Error('KaTeX加载超时'));
}
}, 100);
});
}

// 安全渲染数学公式
async function renderMathSafely(element) {
try {
console.log('开始渲染数学公式，元素:', element);
console.log('元素内容:', element ? element.innerHTML : 'null');
console.log('KaTeX状态:', typeof window.renderMathInElement);

await waitForKaTeX();
if (element && typeof window.renderMathInElement === 'function') {
console.log('调用renderMathInElement，配置:', mathConfig);
window.renderMathInElement(element, mathConfig);
console.log('数学公式渲染完成');
} else {
console.warn('无法渲染数学公式:', {
element: !!element,
renderMathInElement: typeof window.renderMathInElement
});
}
} catch (error) {
console.error('数学公式渲染错误:', error);
}
}

document.addEventListener('DOMContentLoaded', function() {
const messageInput = document.querySelector('.message-input');
const sendButton = document.getElementById('send-button');
const welcomeMessage = document.getElementById('welcome-message');
const chatContent = document.getElementById('chat-content');
const newChatButton = document.getElementById('new-chat-button');
const thinkingToggle = document.getElementById('thinking-toggle');
const searchToggle = document.getElementById('search-toggle');

// 页面加载时重置状态
window.isAIResponding = false;
disableUserInput(false);

// 数学公式库加载检查
console.log('页面加载完成，检查数学公式库...');
console.log('KaTeX:', typeof window.katex);
console.log('renderMathInElement:', typeof window.renderMathInElement);

// 延迟检查以确保所有defer脚本都加载完成
setTimeout(() => {
console.log('延迟检查 - KaTeX:', typeof window.katex);
console.log('延迟检查 - renderMathInElement:', typeof window.renderMathInElement);
if (typeof window.renderMathInElement === 'function') {
console.log('✅ KaTeX渲染函数可用');
} else {
console.error('❌ KaTeX渲染函数不可用');
}
}, 2000);

// 页面卸载前清理状态
window.addEventListener('beforeunload', function() {
  window.isAIResponding = false;
});

// 页面失去焦点时的处理（比如用户切换到其他标签页）
window.addEventListener('visibilitychange', function() {
  if (!document.hidden && window.isAIResponding) {
    // 页面重新获得焦点时，如果状态还是响应中，给予提示
    console.log('页面重新获得焦点，检查AI响应状态');
  }
});

// 调试功能：手动重置状态（在控制台中调用 resetAIState()）
window.resetAIState = function() {
  console.log('手动重置AI响应状态');
  interruptAIResponse();
  showToast('AI状态已重置', 'success');
};

// 调试功能：手动渲染数学公式（在控制台中调用 debugRenderMath()）
window.debugRenderMath = function() {
  console.log('开始调试数学公式渲染...');
  console.log('KaTeX状态:', typeof window.katex);
  console.log('renderMathInElement状态:', typeof window.renderMathInElement);
  
  // 查找所有AI消息并尝试渲染
  const aiMessages = document.querySelectorAll('.ai-content');
  console.log('找到AI消息数量:', aiMessages.length);
  
  aiMessages.forEach((element, index) => {
    console.log(`渲染消息 ${index + 1}:`, element.innerHTML);
    renderMathSafely(element);
  });
  
  return '数学公式调试完成，查看控制台输出';
};
  // 按钮切换功能
  thinkingToggle.addEventListener('click', function() {
    this.classList.toggle('active');
  });
  
  searchToggle.addEventListener('click', function() {
    this.classList.toggle('active');
  });

  // 自动调整文本区域高度
	messageInput.addEventListener('input', function() {
		this.style.height = 'auto';
		this.style.height = (this.scrollHeight > 48) ? this.scrollHeight + 'px' : '48px';
	});
// 发送消息
sendButton.addEventListener('click', async function() {
// 如果AI正在响应，这个按钮现在是中断按钮
if (window.isAIResponding) {
  console.log('用户点击中断按钮，停止AI响应');
  interruptAIResponse();
  showToast('已停止AI回复，现在可以发送新消息', 'success');
  return; // 只中断，不发送消息
}

// 正常发送消息流程
const message = messageInput.value.trim();
if (!message) return;

console.log('发送消息:', message);
// 立即清空输入框并重置高度
messageInput.value = '';
messageInput.style.height = '48px';

// 隐藏欢迎信息，显示聊天内容和新对话按钮
welcomeMessage.classList.add('hidden');
chatContent.classList.remove('hidden');
newChatButton.classList.remove('hidden');

// 发送消息到后端
await sendMessageToAPI(message);
});

// 按 Enter 发送消息
messageInput.addEventListener('keydown', function(e) {
if (e.key === 'Enter' && !e.shiftKey) {
e.preventDefault();

// 如果AI正在响应，显示中断提示
if (window.isAIResponding) {
  console.log('AI正在响应中，显示停止按钮提示');
  showInterruptHint();
  return;
}

// 正常情况下触发发送按钮
sendButton.click();
}
});

// API 交互函数
window.currentChatId = null;
window.isAIResponding = false; // 添加AI响应状态标记
window.currentStreamController = null; // 当前流式响应控制器

// 中断AI响应函数
function interruptAIResponse() {
if (window.currentStreamController) {
  console.log('中断当前AI流式响应');
  window.currentStreamController.abort();
  window.currentStreamController = null;
}
window.isAIResponding = false;
disableUserInput(false);
}

async function sendMessageToAPI(message) {
try {
// 如果已经在响应中，先中断之前的响应
if (window.isAIResponding) {
  interruptAIResponse();
}

// 设置响应状态
window.isAIResponding = true;
disableUserInput(true);

// 创建AbortController用于中断请求
window.currentStreamController = new AbortController();

// 设置超时保护，防止界面永远被锁定
const responseTimeout = setTimeout(() => {
  if (window.isAIResponding) {
    console.log('AI响应超时，重置状态');
    interruptAIResponse();
    showToast('AI响应超时，请重试', 'error');
  }
}, 120000); // 2分钟超时

// 显示用户消息
displayUserMessage(message);

// 显示AI消息占位符
const aiMessageElement = showTypingMessage();

// 使用流式接口
const response = await fetch('/api/chat/stream', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
},
body: JSON.stringify({
message: message,
      chatId: window.currentChatId,
useThinking: thinkingToggle.classList.contains('active'),
useSearch: searchToggle.classList.contains('active')
}),
signal: window.currentStreamController.signal // 添加中断信号
});

if (!response.ok) {
throw new Error('网络请求失败');
}

const reader = response.body.getReader();
const decoder = new TextDecoder();
let aiContent = '';

while (true) {
const { done, value } = await reader.read();
if (done) break;

const chunk = decoder.decode(value);
const lines = chunk.split('\n');

for (const line of lines) {
if (line.startsWith('data: ')) {
try {
const jsonStr = line.slice(6).trim();
if (jsonStr) {
const data = JSON.parse(jsonStr);
if (data.type === 'chatId') {
            // 如果这是一个新的聊天，刷新历史记录
            const isNewChat = !window.currentChatId;
            window.currentChatId = data.chatId;
            if (isNewChat) {
              // 延迟刷新历史记录，给后端一点时间保存
              setTimeout(() => {
                loadChatHistory();
              }, 500);
            }
} else if (data.type === 'content') {
aiContent += data.content;
// 实现打字机效果
typeWriterEffect(aiMessageElement, aiContent);
          } else if (data.type === 'end') {
            // 流式输出结束，清理光标
            finishTyping(aiMessageElement);
            // 重置响应状态，允许用户发送新消息
            window.isAIResponding = false;
            disableUserInput(false);
            window.currentStreamController = null;
            // 清除超时定时器
            clearTimeout(responseTimeout);
            break;
          } else if (data.type === 'error') {
            showErrorMessage(data.error);
            // 出错时也要重置状态
            interruptAIResponse();
            // 清除超时定时器
            clearTimeout(responseTimeout);
            return;
          }
}
} catch (e) {
console.log('跳过无效JSON:', line);
}
}
}
}

} catch (error) {
// 检查是否是用户主动中断
if (error.name === 'AbortError') {
  console.log('用户中断了AI响应');
  return; // 不显示错误消息，因为是用户主动中断
}

console.error('发送消息失败:', error);
showErrorMessage('网络连接失败，请检查网络后重试');
// 出错时重置状态
interruptAIResponse();
// 清除超时定时器
clearTimeout(responseTimeout);
}
}

function displayUserMessage(message) {
const chatContainer = document.getElementById('chat-content');
const now = new Date().toLocaleString('zh-CN');

// 渲染Markdown格式的用户消息
const renderedMessage = renderMarkdown(message);

const userHTML = `
<div class="flex justify-end mb-4">
<div class="max-w-3xl">
<div class="flex justify-end mb-1">
<div class="text-sm text-gray-500">${now}</div>
</div>
<div class="relative group">
<div class="bg-gradient-to-br from-gray-100 via-gray-50 to-white rounded-lg py-3 px-4 text-gray-800 shadow-md hover:shadow-lg transition-shadow duration-300 markdown-content">
${renderedMessage}
</div>
</div>
</div>
</div>
`;

chatContainer.insertAdjacentHTML('beforeend', userHTML);

// 渲染数学公式
const newMessage = chatContainer.querySelector('.markdown-content:last-of-type');
if (newMessage) {
renderMathSafely(newMessage);
}

chatContainer.scrollTop = chatContainer.scrollHeight;
}

function showTypingMessage() {
const chatContainer = document.getElementById('chat-content');
const now = new Date().toLocaleString('zh-CN');

const typingHTML = `
<div class="flex justify-start ai-message">
<div class="max-w-3xl">
<div class="flex items-center gap-2 mb-1">
<div class="font-medium">AI小子</div>
<div class="text-sm text-gray-500">${now}</div>
</div>
<div class="bg-[#F7F8FA] rounded-lg py-3 px-4 text-gray-800 min-h-[1.5rem] markdown-content">
<span class="ai-content"></span>
<span class="typing-cursor">|</span>
</div>
</div>
</div>
`;

chatContainer.insertAdjacentHTML('beforeend', typingHTML);
chatContainer.scrollTop = chatContainer.scrollHeight;

// 添加光标闪烁效果（使用CSS动画）
const cursor = chatContainer.querySelector('.ai-message:last-child .typing-cursor');

// 返回消息元素
const messageElement = chatContainer.querySelector('.ai-message:last-child .ai-content');
return messageElement;
}

function typeWriterEffect(element, fullText) {
// 渲染Markdown并更新内容
const renderedText = renderMarkdown(fullText);
element.innerHTML = renderedText;

// 简化策略：总是尝试渲染数学公式
// 因为KaTeX会自动跳过没有数学公式的内容
console.log('typeWriterEffect: 渲染数学公式');
setTimeout(() => {
    renderMathSafely(element);
}, 50); // 短暂延迟确保DOM更新完成

// 滚动到底部
const chatContainer = document.getElementById('chat-content');
chatContainer.scrollTop = chatContainer.scrollHeight;
}

function finishTyping(element) {
// 清理光标
const cursor = element.parentElement.querySelector('.typing-cursor');
if (cursor) {
cursor.style.display = 'none';
}

// 最终渲染数学公式 - 确保所有公式都被正确渲染
console.log('完成打字效果，强制渲染数学公式');
console.log('最终内容:', element.innerHTML);

// 多次尝试渲染以确保成功
setTimeout(() => renderMathSafely(element), 100);
setTimeout(() => renderMathSafely(element), 500);
setTimeout(() => renderMathSafely(element), 1000);
}

// 显示中断提示
function showInterruptHint() {
const sendButton = document.getElementById('send-button'); // 修正：使用ID选择器
if (!sendButton) return;

// 创建提示框
const hint = document.createElement('div');
hint.className = 'interrupt-hint fixed z-50 bg-gray-800 text-white px-3 py-2 rounded-lg shadow-xl font-medium text-center';
hint.innerHTML = `
  <div class="flex items-center justify-center">
    <i class="ri-arrow-down-line mr-1 text-sm"></i>
    <span class="text-sm">点击下方按钮可停止AI对话</span>
  </div>
`;
hint.style.cssText = `
  animation: bounce-in 0.3s ease-out;
  pointer-events: none;
`;

// 获取发送按钮的位置，提示显示在按钮上方
const buttonRect = sendButton.getBoundingClientRect();
hint.style.position = 'fixed';
hint.style.left = (buttonRect.left + buttonRect.width/2 - 120) + 'px'; // 居中对齐
hint.style.top = (buttonRect.top - 70) + 'px'; // 在按钮上方

document.body.appendChild(hint);

// 让中断按钮闪烁提醒
sendButton.classList.add('animate-pulse');
setTimeout(() => {
  sendButton.classList.remove('animate-pulse');
}, 2000);

// 3秒后自动消失
setTimeout(() => {
  if (document.body.contains(hint)) {
    hint.style.animation = 'fade-out 0.3s ease-in';
    setTimeout(() => {
      if (document.body.contains(hint)) {
        document.body.removeChild(hint);
      }
    }, 300);
  }
}, 3000);

// 播放轻微的震动效果（如果支持）
if (navigator.vibrate) {
  navigator.vibrate(100);
}
}

// 控制用户输入状态
function disableUserInput(disabled) {
const messageInput = document.querySelector('.message-input');
const sendButton = document.getElementById('send-button'); // 修正：使用ID选择器
const thinkingToggle = document.getElementById('thinking-toggle');
const searchToggle = document.getElementById('search-toggle');

if (disabled) {
  // 不禁用输入框，只改变外观提示用户AI正在响应
  messageInput.placeholder = '和AI小子聊天吧...'; // 保持正常提示文字
  
  // 添加边框动画效果提示AI正在响应
  messageInput.style.borderColor = '#3B82F6';
  messageInput.style.boxShadow = '0 0 0 2px rgba(59, 130, 246, 0.1)';
  messageInput.style.animation = 'pulse-border 2s infinite';
  
  if (sendButton) {
    // 修改为停止按钮的样式
    const sendIcon = sendButton.querySelector('i');
    if (sendIcon) {
      sendIcon.className = 'ri-stop-circle-fill'; // 使用实心停止图标
    }
    sendButton.title = '点击停止AI回复';
    // 保持蓝色背景，只改变图标
  }
  
  // 切换按钮保持可用但添加提示
  if (thinkingToggle) {
    thinkingToggle.title = 'AI响应中，新消息生效';
  }
  if (searchToggle) {
    searchToggle.title = 'AI响应中，新消息生效';
  }
} else {
  // 恢复正常状态
  messageInput.placeholder = '和AI小子聊天吧...';
  
  // 移除动画效果
  messageInput.style.borderColor = '';
  messageInput.style.boxShadow = '';
  messageInput.style.animation = '';
  
  if (sendButton) {
    // 恢复发送按钮
    const sendIcon = sendButton.querySelector('i');
    if (sendIcon) {
      sendIcon.className = 'ri-send-plane-fill';
    }
    sendButton.title = '发送消息';
    // 只需要恢复图标，背景色保持不变
  }
  
  // 恢复切换按钮提示
  if (thinkingToggle) {
    thinkingToggle.title = '开启思考过程';
  }
  if (searchToggle) {
    searchToggle.title = '开启联网搜索';
  }
}
}

// 旧的displayMessages函数已被流式显示替代

function showErrorMessage(error) {
// 移除加载消息
const loadingMessage = document.querySelector('.loading-message');
if (loadingMessage) {
loadingMessage.remove();
}

const chatContainer = document.getElementById('chat-content');
const errorHTML = `
<div class="flex justify-start">
<div class="max-w-3xl">
<div class="flex items-center gap-2 mb-1">
<div class="font-medium">AI小子</div>
<div class="text-sm text-gray-500">${new Date().toLocaleString('zh-CN')}</div>
</div>
<div class="bg-red-50 border border-red-200 rounded-lg py-3 px-4 text-red-800">
❌ ${error}
</div>
</div>
</div>
`;
chatContainer.insertAdjacentHTML('beforeend', errorHTML);
chatContainer.scrollTop = chatContainer.scrollHeight;
}

function bindThinkingToggle() {
document.querySelectorAll('.thinking-toggle').forEach(button => {
button.addEventListener('click', function() {
const thinkingProcess = this.nextElementSibling;
thinkingProcess.classList.toggle('expanded');
// 更新箭头图标
const arrowIcon = this.querySelector('.ri-arrow-down-s-line, .ri-arrow-up-s-line');
if (thinkingProcess.classList.contains('expanded')) {
arrowIcon.classList.replace('ri-arrow-down-s-line', 'ri-arrow-up-s-line');
} else {
arrowIcon.classList.replace('ri-arrow-up-s-line', 'ri-arrow-down-s-line');
}
});
});
}

// 加载聊天历史
async function loadChatHistory() {
try {
const response = await fetch('/api/chat/history');
const result = await response.json();
if (result.success) {
updateHistoryList(result.data);
}
} catch (error) {
console.error('加载历史失败:', error);
}
}

function updateHistoryList(history) {
const historyContainer = document.getElementById('history-container');

if (!history || (Object.keys(history).length === 0 && 
    (!history['当天'] || history['当天'].length === 0) &&
    (!history['七天以内'] || history['七天以内'].length === 0) &&
    (!history['一个月以内'] || history['一个月以内'].length === 0) &&
    (!history['更早'] || Object.keys(history['更早']).length === 0))) {
  historyContainer.innerHTML = `
    <div class="p-3 text-center text-gray-500 text-sm">
      <i class="ri-chat-3-line mr-1"></i>
      暂无历史对话
    </div>
  `;
  return;
}

let historyHTML = '';

// 当天
if (history['当天'] && history['当天'].length > 0) {
  historyHTML += `
    <div class="p-3">
      <div class="text-sm text-gray-500 mb-2 flex items-center gap-1">
        <i class="ri-time-line"></i>
        当天
      </div>
      ${history['当天'].map((chat, index) => `
        <div class="history-item py-2 px-3 rounded text-sm mb-1 cursor-pointer hover:bg-gray-50 ${index === 0 ? 'active-chat bg-blue-50 text-blue-700' : ''}" data-chat-id="${chat.id}">
          <div class="flex items-center justify-between group">
            <div class="truncate flex-1 pr-2">${chat.title}</div>
            <div class="opacity-0 group-hover:opacity-100 transition-opacity">
              <button class="delete-chat-btn w-6 h-6 flex items-center justify-center text-red-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-chat-id="${chat.id}" title="删除对话">
                <i class="ri-delete-bin-line text-xs"></i>
              </button>
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// 七天以内
if (history['七天以内'] && history['七天以内'].length > 0) {
  historyHTML += `
    <div class="p-3">
      <div class="text-sm text-gray-500 mb-2 flex items-center gap-1">
        <i class="ri-calendar-line"></i>
        七天以内
      </div>
      ${history['七天以内'].map(chat => `
        <div class="history-item py-2 px-3 rounded text-sm mb-1 cursor-pointer hover:bg-gray-50" data-chat-id="${chat.id}">
          <div class="flex items-center justify-between group">
            <div class="truncate flex-1 pr-2">${chat.title}</div>
            <div class="opacity-0 group-hover:opacity-100 transition-opacity">
              <button class="delete-chat-btn w-6 h-6 flex items-center justify-center text-red-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-chat-id="${chat.id}" title="删除对话">
                <i class="ri-delete-bin-line text-xs"></i>
              </button>
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// 一个月以内
if (history['一个月以内'] && history['一个月以内'].length > 0) {
  historyHTML += `
    <div class="p-3">
      <div class="text-sm text-gray-500 mb-2 flex items-center gap-1">
        <i class="ri-calendar-2-line"></i>
        一个月以内
      </div>
      ${history['一个月以内'].map(chat => `
        <div class="history-item py-2 px-3 rounded text-sm mb-1 cursor-pointer hover:bg-gray-50" data-chat-id="${chat.id}">
          <div class="flex items-center justify-between group">
            <div class="truncate flex-1 pr-2">${chat.title}</div>
            <div class="opacity-0 group-hover:opacity-100 transition-opacity">
              <button class="delete-chat-btn w-6 h-6 flex items-center justify-center text-red-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-chat-id="${chat.id}" title="删除对话">
                <i class="ri-delete-bin-line text-xs"></i>
              </button>
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// 更早的对话（按月份分组）
if (history['更早'] && Object.keys(history['更早']).length > 0) {
  Object.keys(history['更早']).sort().reverse().forEach(monthKey => {
    if (history['更早'][monthKey] && history['更早'][monthKey].length > 0) {
      historyHTML += `
        <div class="p-3">
          <div class="text-sm text-gray-500 mb-2 flex items-center gap-1">
            <i class="ri-history-line"></i>
            ${monthKey}
          </div>
          ${history['更早'][monthKey].map(chat => `
            <div class="history-item py-2 px-3 rounded text-sm mb-1 cursor-pointer hover:bg-gray-50" data-chat-id="${chat.id}">
              <div class="flex items-center justify-between group">
                <div class="truncate flex-1 pr-2">${chat.title}</div>
                <div class="opacity-0 group-hover:opacity-100 transition-opacity">
                  <button class="delete-chat-btn w-6 h-6 flex items-center justify-center text-red-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-chat-id="${chat.id}" title="删除对话">
                    <i class="ri-delete-bin-line text-xs"></i>
                  </button>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      `;
    }
  });
}

if (historyHTML === '') {
  historyHTML = `
    <div class="p-3 text-center text-gray-500 text-sm">
      <i class="ri-chat-3-line mr-1"></i>
      暂无历史对话
    </div>
  `;
}

historyContainer.innerHTML = historyHTML;

// 绑定点击事件
bindHistoryItemEvents();
}

// 绑定历史记录项点击事件
function bindHistoryItemEvents() {
const historyItems = document.querySelectorAll('.history-item');
const deleteButtons = document.querySelectorAll('.delete-chat-btn');

// 绑定历史项点击事件
historyItems.forEach(item => {
  item.addEventListener('click', async function(e) {
    // 如果点击的是删除按钮，不执行历史项点击逻辑
    if (e.target.closest('.delete-chat-btn')) {
      return;
    }
    
    // 移除所有活跃状态
    historyItems.forEach(i => i.classList.remove('active-chat'));
    // 添加当前项的活跃状态
    this.classList.add('active-chat');
    
    // 获取聊天ID
    const chatId = this.getAttribute('data-chat-id');
    if (chatId) {
      await loadChatMessages(chatId);
    }
    
    // 显示聊天内容区域
    document.getElementById('welcome-message').classList.add('hidden');
    document.getElementById('chat-content').classList.remove('hidden');
    document.getElementById('new-chat-button').classList.remove('hidden');
  });
});

// 绑定删除按钮点击事件
deleteButtons.forEach(button => {
  button.addEventListener('click', async function(e) {
    e.stopPropagation(); // 阻止事件冒泡
    
    const chatId = this.getAttribute('data-chat-id');
    const historyItem = this.closest('.history-item');
    const chatTitle = historyItem.querySelector('.truncate').textContent;
    
    // 显示确认对话框
    if (await showDeleteConfirmation(chatTitle)) {
      await deleteChatById(chatId);
    }
  });
});
}

// 加载特定聊天的消息
async function loadChatMessages(chatId) {
try {
  const response = await fetch(`/api/chat/${chatId}`);
  const result = await response.json();
  if (result.success) {
    displayChatMessages(result.data.messages);
    // 设置当前聊天ID
    window.currentChatId = chatId;
  }
} catch (error) {
  console.error('加载聊天消息失败:', error);
  showErrorMessage('加载聊天记录失败');
}
}

// 显示聊天消息
function displayChatMessages(messages) {
const chatContent = document.getElementById('chat-content');
chatContent.innerHTML = '';

messages.forEach(message => {
  if (message.role === 'user') {
    displayUserMessage(message.content);
  } else if (message.role === 'assistant') {
    displayAssistantMessage(message.content, message.thinking, message.searchUsed, message.searchResultsCount);
  }
});
}

// 显示助手消息
function displayAssistantMessage(content, thinking, searchUsed, searchResultsCount) {
const chatContainer = document.getElementById('chat-content');
const now = new Date().toLocaleString('zh-CN');

// 渲染Markdown格式的助手消息
const renderedMessage = renderMarkdown(content);

let thinkingHTML = '';
if (thinking) {
  thinkingHTML = `
    <div class="mb-3">
      <button class="thinking-toggle flex items-center gap-2 text-sm text-blue-600 hover:text-blue-700 bg-blue-50 hover:bg-blue-100 px-3 py-1.5 rounded-lg transition-colors">
        <i class="ri-brain-line"></i>
        <span>思考过程</span>
        <i class="ri-arrow-down-s-line"></i>
      </button>
      <div class="thinking-process mt-2 bg-blue-50 rounded-lg p-3 text-sm text-blue-800">
        ${thinking.content}
      </div>
    </div>
  `;
}

let searchHTML = '';
if (searchUsed) {
  searchHTML = `
    <div class="mb-3 text-xs text-gray-500 flex items-center gap-1">
      <i class="ri-search-line"></i>
      <span>已联网搜索${searchResultsCount ? ` (${searchResultsCount}条结果)` : ''}</span>
    </div>
  `;
}

const assistantHTML = `
  <div class="flex justify-start ai-message">
    <div class="max-w-3xl">
      <div class="flex items-center gap-2 mb-1">
        <div class="font-medium">AI小子</div>
        <div class="text-sm text-gray-500">${now}</div>
      </div>
      ${thinkingHTML}
      ${searchHTML}
      <div class="bg-[#F7F8FA] rounded-lg py-3 px-4 text-gray-800 markdown-content">
        ${renderedMessage}
      </div>
    </div>
  </div>
`;

chatContainer.insertAdjacentHTML('beforeend', assistantHTML);

// 渲染数学公式
const newMessage = chatContainer.querySelector('.ai-message:last-child .markdown-content');
if (newMessage) {
  renderMathSafely(newMessage);
}

// 绑定思考过程切换事件
bindThinkingToggle();

chatContainer.scrollTop = chatContainer.scrollHeight;
}

// 显示删除确认对话框
function showDeleteConfirmation(chatTitle) {
return new Promise((resolve) => {
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
  modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl p-6 max-w-md mx-4 modal-enter">
      <div class="flex items-center mb-4">
        <div class="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center mr-3">
          <i class="ri-delete-bin-line text-red-600"></i>
        </div>
        <h3 class="text-lg font-semibold text-gray-900">删除对话</h3>
      </div>
      <p class="text-gray-600 mb-6">
        确定要删除对话 "<span class="font-medium">${chatTitle}</span>" 吗？<br>
        <span class="text-sm text-red-500">此操作不可撤销。</span>
      </p>
      <div class="flex justify-end gap-3">
        <button class="cancel-btn px-4 py-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-colors">
          取消
        </button>
        <button class="confirm-btn px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors">
          删除
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // 绑定事件
  modal.querySelector('.cancel-btn').addEventListener('click', () => {
    document.body.removeChild(modal);
    resolve(false);
  });
  
  modal.querySelector('.confirm-btn').addEventListener('click', () => {
    document.body.removeChild(modal);
    resolve(true);
  });
  
  // 点击背景关闭
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
      resolve(false);
    }
  });
  
  // ESC键关闭
  const handleEscape = (e) => {
    if (e.key === 'Escape') {
      document.body.removeChild(modal);
      document.removeEventListener('keydown', handleEscape);
      resolve(false);
    }
  };
  document.addEventListener('keydown', handleEscape);
});
}

// 删除聊天
async function deleteChatById(chatId) {
try {
  // 显示删除loading状态
  const historyItem = document.querySelector(`[data-chat-id="${chatId}"]`);
  const deleteBtn = historyItem.querySelector('.delete-chat-btn');
  const originalContent = deleteBtn.innerHTML;
  deleteBtn.innerHTML = '<i class="ri-loader-4-line animate-spin text-xs"></i>';
  deleteBtn.disabled = true;
  
  const response = await fetch(`/api/chat/${chatId}`, {
    method: 'DELETE'
  });
  
  const result = await response.json();
  
  if (result.success) {
    // 删除成功，刷新历史记录
    await loadChatHistory();
    
    // 如果删除的是当前正在查看的聊天，回到欢迎页面
    if (window.currentChatId === chatId) {
      startNewChat();
    }
    
    // 显示成功提示
    showToast('对话删除成功', 'success');
  } else {
    throw new Error(result.error || '删除失败');
  }
  
} catch (error) {
  console.error('删除聊天失败:', error);
  
  // 恢复删除按钮状态
  const historyItem = document.querySelector(`[data-chat-id="${chatId}"]`);
  if (historyItem) {
    const deleteBtn = historyItem.querySelector('.delete-chat-btn');
    deleteBtn.innerHTML = '<i class="ri-delete-bin-line text-xs"></i>';
    deleteBtn.disabled = false;
  }
  
  showToast('删除失败: ' + error.message, 'error');
}
}

// 显示提示消息
function showToast(message, type = 'info') {
const toast = document.createElement('div');
toast.className = `toast fixed top-4 right-4 z-50 px-4 py-3 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full ${
  type === 'success' ? 'bg-green-500 text-white' :
  type === 'error' ? 'bg-red-500 text-white' :
  'bg-blue-500 text-white'
}`;
toast.textContent = message;

document.body.appendChild(toast);

// 显示动画
requestAnimationFrame(() => {
  toast.style.transform = 'translateX(0)';
});

// 3秒后自动消失
setTimeout(() => {
  toast.style.transform = 'translateX(full)';
  setTimeout(() => {
    if (document.body.contains(toast)) {
      document.body.removeChild(toast);
    }
  }, 300);
}, 3000);
}

// 开始新对话
async function startNewChat() {
try {
  // 如果当前有正在进行的对话，先确保它已经保存
  if (window.currentChatId) {
    console.log('保存当前对话到历史记录:', window.currentChatId);
    
    // 给服务器一点时间确保最后的消息已经保存
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 刷新历史记录以显示刚保存的对话
    await loadChatHistory();
  }
  
  // 移除所有历史项的活跃状态
const historyItems = document.querySelectorAll('.history-item');
historyItems.forEach(i => i.classList.remove('active-chat'));

  // 清空聊天内容区域，确保只显示新对话
  const chatContent = document.getElementById('chat-content');
  chatContent.innerHTML = ''; // 清空所有之前的聊天消息
  
  // 显示欢迎消息，隐藏聊天内容和新对话按钮
document.getElementById('welcome-message').classList.remove('hidden');
document.getElementById('chat-content').classList.add('hidden');
document.getElementById('new-chat-button').classList.add('hidden');

  // 清空输入框
  const messageInput = document.querySelector('.message-input');
messageInput.value = '';
messageInput.style.height = '48px';
messageInput.focus();

  // 清除当前聊天ID
  const previousChatId = window.currentChatId;
  window.currentChatId = null;

  // 添加动画效果
const welcomeDiv = document.getElementById('welcome-message');
welcomeDiv.style.opacity = '0';
welcomeDiv.style.transform = 'translateY(20px)';
requestAnimationFrame(() => {
welcomeDiv.style.transition = 'all 0.5s ease';
welcomeDiv.style.opacity = '1';
welcomeDiv.style.transform = 'translateY(0)';
});
  
  // 如果有之前的对话，显示提示
  if (previousChatId) {
    showToast('当前对话已保存到历史记录', 'success');
  }
  
} catch (error) {
  console.error('开启新对话时出错:', error);
  // 即使出错也要允许用户开启新对话
  window.currentChatId = null;
  showToast('开启新对话', 'info');
}
}

// 在第一个DOMContentLoaded中添加新对话按钮事件绑定
// 页面加载时获取历史并绑定按钮事件
setTimeout(() => {
  loadChatHistory();
  
  // 初始化状态
  window.isAIResponding = false;
  disableUserInput(false);
  
  // 新对话按钮点击事件 - 使用类名选择器
  const newChatButtons = document.querySelectorAll('.new-chat-btn');
  newChatButtons.forEach(button => {
    button.addEventListener('click', async function(e) {
      e.preventDefault();
      console.log('新对话按钮被点击');
      
      // 禁用按钮，防止重复点击
      this.disabled = true;
      const originalText = this.querySelector('span').textContent;
      this.querySelector('span').textContent = '保存中...';
      
      try {
        await startNewChat();
      } finally {
        // 恢复按钮状态
        this.disabled = false;
        this.querySelector('span').textContent = originalText;
      }
});
});

  // 也可以通过ID单独绑定
  const sidebarNewChatBtn = document.getElementById('sidebar-new-chat-btn');
  const chatNewChatBtn = document.getElementById('chat-new-chat-btn');

  if (sidebarNewChatBtn) {
    sidebarNewChatBtn.addEventListener('click', async function(e) {
      e.preventDefault();
      console.log('侧边栏新对话按钮被点击');
      
      // 禁用按钮，防止重复点击
      this.disabled = true;
      const originalText = this.querySelector('span').textContent;
      this.querySelector('span').textContent = '保存中...';
      
      try {
        await startNewChat();
      } finally {
        // 恢复按钮状态
        this.disabled = false;
        this.querySelector('span').textContent = originalText;
      }
    });
  }

  if (chatNewChatBtn) {
    chatNewChatBtn.addEventListener('click', async function(e) {
      e.preventDefault();
      console.log('聊天区域新对话按钮被点击');
      
      // 禁用按钮，防止重复点击
      this.disabled = true;
      const originalText = this.querySelector('span').textContent;
      this.querySelector('span').textContent = '保存中...';
      
      try {
        await startNewChat();
      } finally {
        // 恢复按钮状态
        this.disabled = false;
        this.querySelector('span').textContent = originalText;
      }
    });
  }
}, 100);

}); // 结束第一个DOMContentLoaded
</script>
</body>
</html>